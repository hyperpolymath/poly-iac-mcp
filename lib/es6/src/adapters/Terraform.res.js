// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Deno from "../bindings/Deno.res.js";
import * as Adapter from "../Adapter.res.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

let binaryPath = {
  contents: undefined
};

let connected = {
  contents: false
};

async function detectBinary() {
  let binaries = [
    "tofu",
    "terraform"
  ];
  let result;
  for (let i = 0, i_finish = binaries.length; i < i_finish; ++i) {
    if (Stdlib_Option.isNone(result)) {
      let binary = binaries[i];
      try {
        let match = await $$Deno.Command.run(binary, ["version"]);
        if (match[0] === 0) {
          result = binary;
        }
      } catch (exn) {
        
      }
    }
  }
  return result;
}

async function runCommand(args) {
  let binary = binaryPath.contents;
  if (binary === undefined) {
    return {
      success: false,
      error: "Not connected to Terraform/OpenTofu"
    };
  }
  let match = await $$Deno.Command.run(binary, args);
  let code = match[0];
  return {
    success: code === 0,
    output: match[1],
    error: match[2],
    code: code
  };
}

async function connect() {
  let binary = await detectBinary();
  if (binary !== undefined) {
    binaryPath.contents = binary;
    connected.contents = true;
    return;
  } else {
    return Stdlib_Exn.raiseError("No Terraform/OpenTofu binary found");
  }
}

async function disconnect() {
  connected.contents = false;
  binaryPath.contents = undefined;
}

async function isConnected() {
  return connected.contents;
}

async function initHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  let backend = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["backend"], Stdlib_JSON.Decode.bool), true);
  let upgrade = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["upgrade"], Stdlib_JSON.Decode.bool), false);
  let cmdArgs = ["init"];
  if (!backend) {
    cmdArgs.push("-backend=false");
  }
  if (upgrade) {
    cmdArgs.push("-upgrade");
  }
  cmdArgs.push(path);
  return await runCommand(cmdArgs);
}

async function planHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  let out = Stdlib_Option.flatMap(args["out"], Stdlib_JSON.Decode.string);
  let cmdArgs = ["plan"];
  Stdlib_Option.forEach(out, o => {
    cmdArgs.push(`-out=` + o);
  });
  cmdArgs.push(path);
  return await runCommand(cmdArgs);
}

async function applyHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  let autoApprove = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["autoApprove"], Stdlib_JSON.Decode.bool), false);
  let cmdArgs = ["apply"];
  if (autoApprove) {
    cmdArgs.push("-auto-approve");
  }
  cmdArgs.push(path);
  return await runCommand(cmdArgs);
}

async function destroyHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  let autoApprove = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["autoApprove"], Stdlib_JSON.Decode.bool), false);
  let cmdArgs = ["destroy"];
  if (autoApprove) {
    cmdArgs.push("-auto-approve");
  }
  cmdArgs.push(path);
  return await runCommand(cmdArgs);
}

async function outputHandler(args) {
  let outputName = Stdlib_Option.flatMap(args["name"], Stdlib_JSON.Decode.string);
  let json = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["json"], Stdlib_JSON.Decode.bool), true);
  let cmdArgs = ["output"];
  if (json) {
    cmdArgs.push("-json");
  }
  Stdlib_Option.forEach(outputName, n => {
    cmdArgs.push(n);
  });
  return await runCommand(cmdArgs);
}

async function stateListHandler(_args) {
  return await runCommand([
    "state",
    "list"
  ]);
}

async function validateHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  return await runCommand([
    "validate",
    path
  ]);
}

async function fmtHandler(args) {
  let path = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), ".");
  let check = Stdlib_Option.getOr(Stdlib_Option.flatMap(args["check"], Stdlib_JSON.Decode.bool), false);
  let cmdArgs = ["fmt"];
  if (check) {
    cmdArgs.push("-check");
  }
  cmdArgs.push(path);
  return await runCommand(cmdArgs);
}

async function versionHandler(_args) {
  return await runCommand(["version"]);
}

let dict = {};

dict["terraform_init"] = {
  description: "Initialize a Terraform/OpenTofu working directory",
  params: Object.fromEntries([
    [
      "path",
      Adapter.stringParam("Path to configuration directory")
    ],
    [
      "backend",
      Adapter.boolParam("Configure the backend")
    ],
    [
      "upgrade",
      Adapter.boolParam("Upgrade modules and plugins")
    ]
  ]),
  handler: initHandler
};

dict["terraform_plan"] = {
  description: "Generate and show an execution plan",
  params: Object.fromEntries([
    [
      "path",
      Adapter.stringParam("Path to configuration directory")
    ],
    [
      "out",
      Adapter.stringParam("Write plan to a file")
    ]
  ]),
  handler: planHandler
};

dict["terraform_apply"] = {
  description: "Apply infrastructure changes",
  params: Object.fromEntries([
    [
      "path",
      Adapter.stringParam("Path to plan file or configuration")
    ],
    [
      "autoApprove",
      Adapter.boolParam("Skip interactive approval")
    ]
  ]),
  handler: applyHandler
};

dict["terraform_destroy"] = {
  description: "Destroy infrastructure managed by Terraform",
  params: Object.fromEntries([
    [
      "path",
      Adapter.stringParam("Path to configuration directory")
    ],
    [
      "autoApprove",
      Adapter.boolParam("Skip interactive approval")
    ]
  ]),
  handler: destroyHandler
};

dict["terraform_output"] = {
  description: "Show output values from state",
  params: Object.fromEntries([
    [
      "name",
      Adapter.stringParam("Specific output to retrieve")
    ],
    [
      "json",
      Adapter.boolParam("Output in JSON format")
    ]
  ]),
  handler: outputHandler
};

dict["terraform_state_list"] = {
  description: "List resources in the state",
  params: {},
  handler: stateListHandler
};

dict["terraform_validate"] = {
  description: "Validate the configuration files",
  params: Object.fromEntries([[
      "path",
      Adapter.stringParam("Path to configuration directory")
    ]]),
  handler: validateHandler
};

dict["terraform_fmt"] = {
  description: "Format configuration files",
  params: Object.fromEntries([
    [
      "path",
      Adapter.stringParam("Path to configuration directory")
    ],
    [
      "check",
      Adapter.boolParam("Check without modifying")
    ]
  ]),
  handler: fmtHandler
};

dict["terraform_version"] = {
  description: "Show Terraform/OpenTofu version",
  params: {},
  handler: versionHandler
};

let name = "terraform";

let description = "Terraform/OpenTofu Infrastructure as Code";

let tools = dict;

export {
  binaryPath,
  connected,
  detectBinary,
  runCommand,
  name,
  description,
  connect,
  disconnect,
  isConnected,
  initHandler,
  planHandler,
  applyHandler,
  destroyHandler,
  outputHandler,
  stateListHandler,
  validateHandler,
  fmtHandler,
  versionHandler,
  tools,
}
/*  Not a pure module */
